"""Type stubs for the native Rust extension module."""

from typing import Any, Callable, Dict, List, Optional, Sequence, TypeVar, Union

# ─── Strings ─────────────────────────────────────────────────────────────────

def camel_case(input: Union[str, List[str]]) -> Union[str, List[str]]: ...
def kebab_case(input: Union[str, List[str]]) -> Union[str, List[str]]: ...
def pascal_case(input: Union[str, List[str]]) -> Union[str, List[str]]: ...
def snake_case(input: Union[str, List[str]]) -> Union[str, List[str]]: ...
def capitalize(input: Union[str, List[str]]) -> Union[str, List[str]]: ...
def upper_case(input: Union[str, List[str]]) -> Union[str, List[str]]: ...
def lower_case(input: Union[str, List[str]]) -> Union[str, List[str]]: ...
def trim(input: Union[str, List[str]]) -> Union[str, List[str]]: ...
def trim_start(input: Union[str, List[str]]) -> Union[str, List[str]]: ...
def trim_end(input: Union[str, List[str]]) -> Union[str, List[str]]: ...
def words(input: Union[str, List[str]]) -> Union[str, List[str]]: ...

# ─── Numbers ─────────────────────────────────────────────────────────────────

def sum(values: List[Union[int, float]]) -> Union[int, float]: ...
def mean(values: List[Union[int, float]]) -> float: ...
def min(values: List[Union[int, float]]) -> Union[int, float]: ...
def max(values: List[Union[int, float]]) -> Union[int, float]: ...
def round(value: Union[float, List[float]], decimals: int) -> Union[float, List[float]]: ...
def sum_by(values: List[Any], fn: Callable[[Any], float]) -> float: ...
def min_by(values: List[Any], fn: Callable[[Any], float]) -> Optional[Any]: ...
def max_by(values: List[Any], fn: Callable[[Any], float]) -> Optional[Any]: ...

# ─── Arrays ──────────────────────────────────────────────────────────────────

def chunk(array: List[Any], size: int) -> List[List[Any]]: ...
def compact(array: List[Any]) -> List[Any]: ...
def flatten_deep(array: List[List[Any]]) -> List[Any]: ...
def unique(array: List[Any]) -> List[Any]: ...
def group_by(array: List[Any], fn: Callable[[Any], Any]) -> Dict[Any, List[Any]]: ...
def map(array: List[Any], fn: Callable[[Any], Any]) -> List[Any]: ...
def filter(array: List[Any], fn: Callable[[Any], bool]) -> List[Any]: ...
def find(array: List[Any], fn: Callable[[Any], bool]) -> Optional[Any]: ...
def sort_by(array: List[Any], fn: Callable[[Any], Any]) -> List[Any]: ...
def reduce(array: List[Any], fn: Callable[[Any, Any], Any], initial: Any) -> Any: ...
def zip(a: List[Any], b: List[Any]) -> List[List[Any]]: ...
def intersection(a: List[Any], b: List[Any]) -> List[Any]: ...

# ─── Objects ─────────────────────────────────────────────────────────────────

def get(obj: Any, path: str, default: Any) -> Any: ...
def has(obj: Any, path: str) -> bool: ...
def get_all(obj: Any, pattern: str) -> List[Any]: ...
def has_all(obj: Any, pattern: str) -> bool: ...
def pick(obj: Dict[str, Any], keys: List[str]) -> Dict[str, Any]: ...
def omit(obj: Dict[str, Any], keys: List[str]) -> Dict[str, Any]: ...
def merge(objects: List[Dict[str, Any]]) -> Dict[str, Any]: ...
def keys(obj: Dict[str, Any]) -> List[str]: ...
def values(obj: Dict[str, Any]) -> List[Any]: ...
